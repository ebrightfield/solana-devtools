use anchor_lang::{AccountDeserialize, AccountSerialize, system_program};
use solana_program::pubkey::Pubkey;
use solana_client::rpc_client::RpcClient;
use solana_program::clock::Epoch;
use anchor_cli::config::AccountEntry;
use std::fs::File;
use serde_json::json;
use solana_account_decoder::{UiAccount, UiAccountData, UiAccountEncoding};
use solana_sdk::bs58;
use inflector::Inflector;

pub const THOUSAND_SOL: u64 = 1_000_000_000_000;

/// Builds JSON files consumable by `solana-test-validator`. Also handles other code-gen,
/// such as JS imports for test files, and inclusion of pre-loaded accounts in `Test.toml`.
#[derive(Debug, Clone, Default)]
pub struct LocalnetAccount {
    pub address: Pubkey,
    pub lamports: u64,
    pub account_data: Vec<u8>,
    pub owner: Pubkey,
    pub executable: bool,
    pub rent_epoch: Epoch,
    pub name: String,
}

impl LocalnetAccount {
    pub fn new<T: AccountSerialize + AccountDeserialize>(
        address: Pubkey,
        name: String,
        account_data: T,
    ) -> Self {
        let mut serialized = Vec::new();
        account_data.try_serialize(&mut serialized).unwrap();
        Self {
            address,
            lamports: THOUSAND_SOL,
            name,
            account_data: serialized,
            owner: system_program::ID,
            executable: false,
            rent_epoch: 0,
        }
    }

    pub fn new_raw(
        address: Pubkey,
        name: String,
        account_data: Vec<u8>,
    ) -> Self {
        Self {
            address,
            lamports: THOUSAND_SOL,
            name,
            account_data,
            owner: system_program::ID,
            executable: false,
            rent_epoch: 0,
        }
    }

    /// Copy and potentially modify an on-chain account.
    pub fn new_from_clone<T: AccountSerialize + AccountDeserialize, F: FnOnce(T)->T>(
        address: &Pubkey,
        client: &RpcClient,
        name: String,
        modify: Option<F>,
    ) -> anyhow::Result<Self> {
        let info = client.get_account(address)?;
        // Even if there is no modify function, deserialization verifies the expected account type
        let mut deserialized = T::try_deserialize(&mut info.data.as_slice())?;
        // Maybe modify the account data.
        if let Some(func) = modify {
            deserialized = func(deserialized);
        }
        let mut serialized = Vec::new();
        deserialized.try_serialize(&mut serialized)?;
        Ok(Self {
            address: address.clone(),
            lamports: info.lamports,
            name,
            account_data: serialized,
            owner: info.owner,
            executable: info.executable,
            rent_epoch: info.rent_epoch,
        })
    }

    /// There is no modification on this contructor, but also no deserialization.
    /// This is useful for blindly cloning accounts without having access to
    /// any type to which the data can deserialize.
    pub fn new_from_clone_unchecked(
        address: &Pubkey,
        client: &RpcClient,
        name: String,
    ) -> anyhow::Result<Self> {
        let info = client.get_account(address)?;
        Ok(Self {
            address: address.clone(),
            lamports: info.lamports,
            name,
            account_data: info.data,
            owner: info.owner,
            executable: info.executable,
            rent_epoch: info.rent_epoch,
        })
    }

    pub fn set_lamports(mut self, balance: u64) -> Self {
        self.lamports = balance;
        self
    }

    pub fn set_owner(mut self, owner: Pubkey) -> Self {
        self.owner = owner;
        self
    }

    pub fn set_executable(mut self, executable: bool) -> Self {
        self.executable = executable;
        self
    }

    pub fn set_rent_epoch(mut self, rent_epoch: Epoch) -> Self {
        self.rent_epoch = rent_epoch;
        self
    }

    pub fn set_address(mut self, address: Pubkey) -> Self {
        self.address = address;
        self
    }

    /// For inclusion in autogenerated `Test.toml` files.
    pub fn to_account_entry(&self) -> AccountEntry {
        AccountEntry {
            address: self.address.to_string(),
            filename: self.name.to_owned(),
        }
    }

    /// For inclusion in autogenerated imports that can be used
    /// in testing.
    pub fn js_import(&self) -> String {
        js_test_import(&self.name)
    }

    /// Write to a JSON file that can be consumed by `--account` flags in
    /// `solana-test-validator`.
    pub fn write_to_validator_json_file(&self, path_prefix: &str) -> anyhow::Result<()> {
        let ui_act = UiAccount {
            lamports: self.lamports,
            data: UiAccountData::Binary(
                bs58::encode(&self.account_data).into_string(),
                UiAccountEncoding::Base58
            ),
            owner: self.owner.to_string(),
            executable: self.executable,
            ..Default::default()
        };
        let pubkey = self.address.to_string();
        let file = File::create(format!("{}/{}", path_prefix, &self.name))?;
        serde_json::to_writer_pretty(
            file,
            &json!({
                    "pubkey": pubkey,
                    "account": &ui_act,
                }),
        )?;
        Ok(())
    }
}

/// Takes a filepath to a JSON file, and produces a source code string
/// that both imports the JSON as well as extracts the public key object.
/// JS identifier for each pubkey is based off the JSON filename.
pub fn js_test_import(location: &str) -> String {
    let location = if !location.ends_with(".json") {
        location.to_string()
    } else {
        let (location, _) = location.split_at(location.len()-5);
        location.to_string()
    };
    let name = {
        let mut pieces = location.rsplit('/');
        match pieces.next() {
            Some(p) => p.to_string(),
            None => location.to_string(),
        }
    };
    // Turn it into "camelCase" ending in "Json", e.g. i_mint.json -> iMintJson.
    let name = name.to_string().to_camel_case();
    // Output an import statement
    // and its subsequent extraction of the Typescript `PublicKey` object.
    format!("import * as {}Json from \"./{}.json\";\nexport const {} = new anchor.web3.PublicKey({}Json.pubkey);", &name, &location, &name, &name)
}
